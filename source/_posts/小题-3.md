title: 小题(3)
date: 2015-12-07 23:14:01
categories: 技术
tags: [算法, algorithm]
---

闲逛水木，又碰到有人讨论算法小题，题目是这样：数组有N+M个数字, 数字的范围为1 ... N, 打印重复的元素, 要求O(M + N), 不可以用额外的空间。

<!-- more -->

一个思路是，如果这些数字都按照自然的顺序排列，data[0] = 1, data[1] = 2 ... data[K] = K - 1，则由于数字范围为1 ... N， 而需要填补的位置是 M + N，必然有不能放在“正确”位置上的数字，这些不在“正确”位置上的数字必然就是重复的。又由于不能使用额外空间，就要利用这个数组本身的空间来腾挪。于是乎，代码如下：

```cpp
void printDup(vector<int>& data) {
    for( int i=0; i<data.size(); i++ ) {
        while( data[i] != data[data[i]-1] ) {
            swap( data[i], data[data[i]-1] );
        }
    }

    for( int i=0; i<sz; i++ ) {
        if( data[i]-1 != i ) cout<<data[i]<<" ";
    }
    cout<<endl;
}

```
关键的一步是嵌套的第二重while循环，其目的是尽量使得data[i] - 1 = i，如果不能那就算了，留其在原位。那么问题是，这个循环执行多少步？是否一定能够保证任何一个不重复的数字K，能够被放到data[K-1]的位置上？只要这两个问题的答案是令人满意的，这个算法就是高效的。

循环结束的条件是data[i] == data[data[i]-1]，当其结束时，至少data[data[i]-1]已经在正确的位置上了，这其中运行多少次，就有多少个数字归位。但是由于数字范围为1 ... N，最多有N个数能归位，每一个归位的数字只要在另一次while循环中被碰到，就会结束while循环。所以，即使不能明确说出某次while循环运行了多少次，总的while循环次数不会超过N。另一个问题，怎么知道一个不重复的K一定可以被正确归位？换个方式问这个问题，如果K不放在data[K-1]上，它能放到哪里去？若 data[M] = K，则 data[data[M]-1] = data[K-1]，如果data[M]-1是个重复的数字，则有data[data[M]-1] = data[M]（重复的数字至少得有个在正确的位置上），所以data[M] = data[K-1] = K，推回来了。如果data[M]-1也不重复，且data[M]-1也不在其正确位置上，这问题变成了另一个，K不重复且不在其位置上，则K-1也是这样，如此这般推下去一直到14。可是1只要存在，一定是可以放到正确的位置上，不信可以在脑子里推一推。

